import request from 'supertest';\nimport express from 'express';\nimport jwt from 'jsonwebtoken';\nimport { AuthService } from '../../auth/auth-service.js';\nimport { AuthRoutes } from '../../auth/auth.routes.js';\nimport { ApiRateLimiter } from '../../api/api-rate-limiter.js';\n\n// Mock environment variables\nprocess.env.JWT_SECRET = 'test-secret';\nprocess.env.JWT_EXPIRES_IN = '3600';\nprocess.env.JWT_REFRESH_SECRET = 'test-refresh-secret';\nprocess.env.JWT_REFRESH_EXPIRES_IN = '604800';\n\ndescribe('Auth Security Tests', () => {\n  let app: express.Application;\n  let authService: AuthService;\n  \n  beforeEach(() => {\n    app = express();\n    app.use(express.json());\n    \n    // Create auth service with mock methods\n    authService = new AuthService();\n    \n    // Mock login method\n    authService.login = jest.fn().mockImplementation((username, password) => {\n      if (username === 'validuser' && password === 'validpassword') {\n        return Promise.resolve({\n          accessToken: 'valid-access-token',\n          refreshToken: 'valid-refresh-token',\n          user: { id: 1, username: 'validuser', roles: ['user'] }\n        });\n      } else if (username === 'admin' && password === 'adminpassword') {\n        return Promise.resolve({\n          accessToken: 'valid-admin-token',\n          refreshToken: 'valid-admin-refresh-token',\n          user: { id: 2, username: 'admin', roles: ['admin'] }\n        });\n      } else {\n        return Promise.reject(new Error('Invalid username or password'));\n      }\n    });\n    \n    // Mock verify token method\n    authService.verifyToken = jest.fn().mockImplementation((token) => {\n      if (token === 'valid-access-token') {\n        return { userId: 1, username: 'validuser', roles: ['user'] };\n      } else if (token === 'valid-admin-token') {\n        return { userId: 2, username: 'admin', roles: ['admin'] };\n      } else if (token === 'expired-token') {\n        throw new jwt.TokenExpiredError('jwt expired', new Date());\n      } else {\n        throw new Error('Invalid token');\n      }\n    });\n    \n    // Mock refresh token method\n    authService.refreshToken = jest.fn().mockImplementation((refreshToken) => {\n      if (refreshToken === 'valid-refresh-token') {\n        return { accessToken: 'new-access-token' };\n      } else if (refreshToken === 'valid-admin-refresh-token') {\n        return { accessToken: 'new-admin-access-token' };\n      } else {\n        throw new Error('Invalid refresh token');\n      }\n    });\n    \n    // Set up auth routes\n    const authRoutes = new AuthRoutes(authService);\n    app.use('/auth', authRoutes.getRouter());\n  });\n  \n  describe('Authentication Failures', () => {\n    test('should return 401 for invalid login credentials', async () => {\n      const response = await request(app)\n        .post('/auth/login')\n        .send({ username: 'invaliduser', password: 'invalidpassword' });\n      \n      expect(response.status).toBe(401);\n      expect(response.body).toHaveProperty('error');\n    });\n    \n    test('should return 401 for invalid token', async () => {\n      const response = await request(app)\n        .get('/auth/validate')\n        .set('Authorization', 'Bearer invalid-token');\n      \n      expect(response.status).toBe(401);\n      expect(response.body).toHaveProperty('error');\n    });\n    \n    test('should return 401 for expired token', async () => {\n      const response = await request(app)\n        .get('/auth/validate')\n        .set('Authorization', 'Bearer expired-token');\n      \n      expect(response.status).toBe(401);\n      expect(response.body).toHaveProperty('error', 'Token expired');\n    });\n  });\n  \n  describe('Authorization Security', () => {\n    test('should return 403 for non-admin accessing admin route', async () => {\n      const response = await request(app)\n        .get('/auth/admin')\n        .set('Authorization', 'Bearer valid-access-token');\n      \n      expect(response.status).toBe(403);\n      expect(response.body).toHaveProperty('error', 'Access denied');\n    });\n    \n    test('should allow admin to access admin route', async () => {\n      const response = await request(app)\n        .get('/auth/admin')\n        .set('Authorization', 'Bearer valid-admin-token');\n      \n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty('message', 'Admin access granted');\n    });\n  });\n  \n  describe('Token Security', () => {\n    test('should not accept token in query parameters', async () => {\n      const response = await request(app)\n        .get('/auth/validate?token=valid-access-token');\n      \n      expect(response.status).toBe(401);\n    });\n    \n    test('should accept token in authorization header', async () => {\n      const response = await request(app)\n        .get('/auth/validate')\n        .set('Authorization', 'Bearer valid-access-token');\n      \n      expect(response.status).toBe(200);\n    });\n  });\n});\n\ndescribe('Rate Limiting Security', () => {\n  let app: express.Application;\n  let rateLimiter: ApiRateLimiter;\n  \n  beforeEach(() => {\n    app = express();\n    app.use(express.json());\n    \n    // Configure rate limiter with restrictive settings for tests\n    rateLimiter = new ApiRateLimiter({\n      points: 3,               // Allow only 3 requests\n      duration: 60,            // Per minute\n      keyGenerator: (req) => req.ip || 'test-ip',\n    });\n    \n    // Apply rate limiter to app\n    app.use(rateLimiter.middleware());\n    \n    // Simple endpoint for testing\n    app.get('/test', (req, res) => {\n      res.status(200).json({ message: 'Success' });\n    });\n  });\n  \n  test('should rate limit after specified number of requests', async () => {\n    // First requests should succeed\n    for (let i = 0; i < 3; i++) {\n      const response = await request(app).get('/test');\n      expect(response.status).toBe(200);\n    }\n    \n    // Next request should be rate limited\n    const limitedResponse = await request(app).get('/test');\n    expect(limitedResponse.status).toBe(429);\n    expect(limitedResponse.body).toHaveProperty('error', 'Too Many Requests');\n  });\n});\n