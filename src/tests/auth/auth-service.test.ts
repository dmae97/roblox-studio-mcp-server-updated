import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { AuthService } from '../../auth/auth-service.js';\n\n// Mock jwt and bcrypt modules\njest.mock('jsonwebtoken');\njest.mock('bcrypt');\n\n// Mock environment variables\nprocess.env.JWT_SECRET = 'test-secret';\nprocess.env.JWT_EXPIRES_IN = '3600';\nprocess.env.JWT_REFRESH_SECRET = 'test-refresh-secret';\nprocess.env.JWT_REFRESH_EXPIRES_IN = '604800';\n\ndescribe('AuthService', () => {\n  let authService: AuthService;\n\n  beforeEach(() => {\n    authService = new AuthService();\n    jest.clearAllMocks();\n  });\n\n  describe('login', () => {\n    test('should return tokens for valid credentials', async () => {\n      // Mock user data from database\n      const mockUser = {\n        id: 1,\n        username: 'testuser',\n        password: 'hashedpassword',\n        roles: ['user']\n      };\n\n      // Mock bcrypt compare to return true (valid password)\n      (bcrypt.compare as jest.Mock).mockResolvedValue(true);\n\n      // Mock JWT sign function\n      (jwt.sign as jest.Mock).mockImplementation((payload, secret, options) => {\n        if (secret === process.env.JWT_SECRET) return 'mock-access-token';\n        if (secret === process.env.JWT_REFRESH_SECRET) return 'mock-refresh-token';\n        return '';\n      });\n\n      // Mock findUserByUsername method\n      authService.findUserByUsername = jest.fn().mockResolvedValue(mockUser);\n\n      const result = await authService.login('testuser', 'password');\n\n      expect(authService.findUserByUsername).toHaveBeenCalledWith('testuser');\n      expect(bcrypt.compare).toHaveBeenCalledWith('password', 'hashedpassword');\n      expect(jwt.sign).toHaveBeenCalledTimes(2);\n      expect(result).toEqual({\n        accessToken: 'mock-access-token',\n        refreshToken: 'mock-refresh-token',\n        user: { id: 1, username: 'testuser', roles: ['user'] }\n      });\n    });\n\n    test('should throw error for invalid username', async () => {\n      // Mock findUserByUsername to return null (user not found)\n      authService.findUserByUsername = jest.fn().mockResolvedValue(null);\n\n      await expect(authService.login('nonexistent', 'password'))\n        .rejects\n        .toThrow('Invalid username or password');\n\n      expect(authService.findUserByUsername).toHaveBeenCalledWith('nonexistent');\n      expect(bcrypt.compare).not.toHaveBeenCalled();\n      expect(jwt.sign).not.toHaveBeenCalled();\n    });\n\n    test('should throw error for invalid password', async () => {\n      // Mock user data from database\n      const mockUser = {\n        id: 1,\n        username: 'testuser',\n        password: 'hashedpassword',\n        roles: ['user']\n      };\n\n      // Mock findUserByUsername to return a user\n      authService.findUserByUsername = jest.fn().mockResolvedValue(mockUser);\n\n      // Mock bcrypt compare to return false (invalid password)\n      (bcrypt.compare as jest.Mock).mockResolvedValue(false);\n\n      await expect(authService.login('testuser', 'wrongpassword'))\n        .rejects\n        .toThrow('Invalid username or password');\n\n      expect(authService.findUserByUsername).toHaveBeenCalledWith('testuser');\n      expect(bcrypt.compare).toHaveBeenCalledWith('wrongpassword', 'hashedpassword');\n      expect(jwt.sign).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('verifyToken', () => {\n    test('should return decoded token for valid access token', () => {\n      const mockDecodedToken = { userId: 1, username: 'testuser', roles: ['user'] };\n      \n      // Mock jwt verify function\n      (jwt.verify as jest.Mock).mockImplementation(() => mockDecodedToken);\n\n      const result = authService.verifyToken('valid-token');\n\n      expect(jwt.verify).toHaveBeenCalledWith('valid-token', process.env.JWT_SECRET);\n      expect(result).toEqual(mockDecodedToken);\n    });\n\n    test('should throw error for invalid token', () => {\n      // Mock jwt verify to throw an error\n      (jwt.verify as jest.Mock).mockImplementation(() => {\n        throw new Error('Invalid token');\n      });\n\n      expect(() => authService.verifyToken('invalid-token'))\n        .toThrow('Invalid token');\n\n      expect(jwt.verify).toHaveBeenCalledWith('invalid-token', process.env.JWT_SECRET);\n    });\n  });\n\n  describe('refreshToken', () => {\n    test('should generate new access token from valid refresh token', () => {\n      const mockDecodedRefreshToken = { userId: 1, username: 'testuser', roles: ['user'] };\n      \n      // Mock jwt verify function for refresh token\n      (jwt.verify as jest.Mock).mockImplementation(() => mockDecodedRefreshToken);\n\n      // Mock jwt sign function for new access token\n      (jwt.sign as jest.Mock).mockReturnValue('new-access-token');\n\n      const result = authService.refreshToken('valid-refresh-token');\n\n      expect(jwt.verify).toHaveBeenCalledWith('valid-refresh-token', process.env.JWT_REFRESH_SECRET);\n      expect(jwt.sign).toHaveBeenCalled();\n      expect(result).toEqual({ accessToken: 'new-access-token' });\n    });\n\n    test('should throw error for invalid refresh token', () => {\n      // Mock jwt verify to throw an error\n      (jwt.verify as jest.Mock).mockImplementation(() => {\n        throw new Error('Invalid refresh token');\n      });\n\n      expect(() => authService.refreshToken('invalid-refresh-token'))\n        .toThrow('Invalid refresh token');\n\n      expect(jwt.verify).toHaveBeenCalledWith('invalid-refresh-token', process.env.JWT_REFRESH_SECRET);\n      expect(jwt.sign).not.toHaveBeenCalled();\n    });\n  });\n});\n