import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { logger } from '../utils/logger.js';\n\n/**\n * @typedef {Object} User\n * @property {number} id - User ID\n * @property {string} username - Username\n * @property {string} password - Hashed password\n * @property {string[]} roles - User roles (e.g., 'user', 'admin')\n */\n\n/**\n * @typedef {Object} LoginResponse\n * @property {string} accessToken - JWT access token\n * @property {string} refreshToken - JWT refresh token\n * @property {Object} user - User information (without password)\n */\n\n/**\n * @typedef {Object} RefreshTokenResponse\n * @property {string} accessToken - New JWT access token\n */\n\n/**\n * Authentication Service\n * \n * Handles user authentication, token generation, and verification\n * @class\n */\nexport class AuthService {\n  /**\n   * Creates an instance of AuthService\n   */\n  constructor() {\n    // Validate required environment variables\n    this.validateEnvVars();\n  }\n\n  /**\n   * Validates that all required environment variables are set\n   * @private\n   * @throws {Error} If any required environment variable is missing\n   */\n  validateEnvVars() {\n    const requiredVars = [\n      'JWT_SECRET',\n      'JWT_EXPIRES_IN',\n      'JWT_REFRESH_SECRET',\n      'JWT_REFRESH_EXPIRES_IN',\n    ];\n\n    for (const varName of requiredVars) {\n      if (!process.env[varName]) {\n        throw new Error(`Missing required environment variable: ${varName}`);\n      }\n    }\n  }\n\n  /**\n   * Find a user by username\n   * @async\n   * @param {string} username - Username to look up\n   * @returns {Promise<User|null>} User object if found, null otherwise\n   */\n  async findUserByUsername(username) {\n    // Mock database - in a real app, this would query a database\n    const users = [\n      {\n        id: 1,\n        username: 'admin',\n        // Hashed 'adminpassword'\n        password: '$2b$10$NVpkR5H9Gs4c2Vb3ZyJRH.l9eKKTMVb5l0xLpE1xG53jdTRmh5wJO',\n        roles: ['admin', 'user'],\n      },\n      {\n        id: 2,\n        username: 'user',\n        // Hashed 'userpassword'\n        password: '$2b$10$rWVW2sFJ8T5VLRmD1/iQB.iyXm/SwoPoHM0Dh1.WFjLhtXULBVGH6',\n        roles: ['user'],\n      },\n    ];\n\n    const user = users.find(u => u.username === username);\n    return user || null;\n  }\n\n  /**\n   * Authenticate user and generate tokens\n   * @async\n   * @param {string} username - Username\n   * @param {string} password - Plain text password\n   * @returns {Promise<LoginResponse>} Login response with tokens and user info\n   * @throws {Error} If authentication fails\n   */\n  async login(username, password) {\n    // Find user\n    const user = await this.findUserByUsername(username);\n    if (!user) {\n      logger.warn(`Login attempt failed: User ${username} not found`);\n      throw new Error('Invalid username or password');\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      logger.warn(`Login attempt failed: Invalid password for user ${username}`);\n      throw new Error('Invalid username or password');\n    }\n\n    // Generate tokens\n    const accessToken = this.generateAccessToken(user);\n    const refreshToken = this.generateRefreshToken(user);\n\n    logger.info(`User ${username} logged in successfully`);\n\n    // Return tokens and user info (without password)\n    const { password: _, ...userWithoutPassword } = user;\n    return {\n      accessToken,\n      refreshToken,\n      user: userWithoutPassword,\n    };\n  }\n\n  /**\n   * Generate JWT access token\n   * @private\n   * @param {User} user - User object\n   * @returns {string} JWT access token\n   */\n  generateAccessToken(user) {\n    const payload = {\n      userId: user.id,\n      username: user.username,\n      roles: user.roles,\n    };\n\n    return jwt.sign(payload, process.env.JWT_SECRET, {\n      expiresIn: process.env.JWT_EXPIRES_IN,\n    });\n  }\n\n  /**\n   * Generate JWT refresh token\n   * @private\n   * @param {User} user - User object\n   * @returns {string} JWT refresh token\n   */\n  generateRefreshToken(user) {\n    const payload = {\n      userId: user.id,\n      username: user.username,\n      roles: user.roles,\n    };\n\n    return jwt.sign(payload, process.env.JWT_REFRESH_SECRET, {\n      expiresIn: process.env.JWT_REFRESH_EXPIRES_IN,\n    });\n  }\n\n  /**\n   * Verify JWT token and return decoded payload\n   * @param {string} token - JWT token to verify\n   * @returns {Object} Decoded token payload\n   * @throws {Error} If token is invalid or expired\n   */\n  verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET);\n    } catch (error) {\n      if (error instanceof jwt.TokenExpiredError) {\n        logger.warn('Token verification failed: Token expired');\n        throw new Error('Token expired');\n      }\n      logger.warn(`Token verification failed: ${error.message}`);\n      throw new Error('Invalid token');\n    }\n  }\n\n  /**\n   * Generate new access token from refresh token\n   * @param {string} refreshToken - Refresh token\n   * @returns {RefreshTokenResponse} Object containing new access token\n   * @throws {Error} If refresh token is invalid or expired\n   */\n  refreshToken(refreshToken) {\n    try {\n      // Verify refresh token\n      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\n\n      // Generate new access token\n      const accessToken = jwt.sign(\n        {\n          userId: decoded.userId,\n          username: decoded.username,\n          roles: decoded.roles,\n        },\n        process.env.JWT_SECRET,\n        { expiresIn: process.env.JWT_EXPIRES_IN }\n      );\n\n      logger.info(`New access token generated for user ${decoded.username}`);\n\n      return { accessToken };\n    } catch (error) {\n      logger.warn(`Refresh token verification failed: ${error.message}`);\n      throw new Error('Invalid refresh token');\n    }\n  }\n\n  /**\n   * Check if user has required role\n   * @param {Object} user - User object with roles property\n   * @param {string} requiredRole - Role to check for\n   * @returns {boolean} True if user has the required role, false otherwise\n   */\n  hasRole(user, requiredRole) {\n    return Array.isArray(user.roles) && user.roles.includes(requiredRole);\n  }\n}\n