import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport http from 'http';\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';\nimport dotenv from 'dotenv';\nimport { robloxTools } from './tools/index.js';\nimport { robloxResources } from './resources/index.js';\nimport { robloxPrompts } from './prompts/index.js';\nimport { logger } from './utils/logger.js';\nimport { errorHandler, notFound, ApiError } from './middleware/errorHandler.js';\nimport { ApiRateLimiter } from './api/api-rate-limiter.js';\nimport { validateEnvVars } from './middleware/security.js';\nimport { ConnectionManager } from './connection/connection-manager.js';\nimport { WebSocketHandler } from './api/websocket-handler.js';\nimport { ApiVersionManager } from './api/version-manager.js';\nimport { cache } from './utils/cache.js';\nimport { AuthRoutes } from './auth/auth.routes.js';\nimport { metricsMiddleware, getMetrics } from './middleware/metrics.js';\nimport { setupSwagger } from '../swagger.js';\n\n// Load environment variables\ndotenv.config();\n\n// Server configuration\nconst PORT = process.env.PORT || 3000;\nconst SERVER_NAME = process.env.SERVER_NAME || 'Roblox Studio MCP Server';\nconst SERVER_VERSION = process.env.SERVER_VERSION || '1.0.0';\nconst DEBUG = process.env.DEBUG === 'true';\nconst NODE_ENV = process.env.NODE_ENV || 'development';\nconst ENABLE_RATE_LIMITING = process.env.ENABLE_RATE_LIMITING !== 'false';\n\n// Create MCP Server\nconst mcpServer = new McpServer({\n  name: SERVER_NAME,\n  version: SERVER_VERSION\n});\n\n// Register tools, resources, and prompts\nrobloxTools.register(mcpServer);\nrobloxResources.register(mcpServer);\nrobloxPrompts.register(mcpServer);\n\n// Create Express app\nconst app = express();\n\n// Create HTTP server\nconst server = http.createServer(app);\n\n// Create connection manager\nconst connectionManager = new ConnectionManager();\n\n// Create WebSocket handler\nconst wsHandler = new WebSocketHandler(server, mcpServer, connectionManager);\n\n// Create API version manager\nconst apiVersionManager = new ApiVersionManager();\n\n// Register API version v1\nconst v1Router = express.Router();\nv1Router.use('/auth', new AuthRoutes().getRouter());\napiVersionManager.registerVersion({ version: 'v1', router: v1Router });\n\n// Set default API version\napiVersionManager.setDefaultVersion('v1');\n\n// Middleware\napp.use(helmet()); // Adds various HTTP security headers\napp.use(cors({\n  origin: process.env.CORS_ORIGINS === '*' ? '*' : process.env.CORS_ORIGINS?.split(','),\n  methods: ['GET', 'POST', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization']\n}));\napp.use(express.json());\napp.use(validateEnvVars);\napp.use(metricsMiddleware);\n\n// Set up Swagger API documentation\nsetupSwagger(app);\n\n// Add request logging middleware\napp.use((req, res, next) => {\n  const start = Date.now();\n  \n  // Log when the response is finished\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    const logLevel = res.statusCode >= 400 ? 'warn' : 'info';\n    \n    logger[logLevel](\n      `${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`\n    );\n  });\n  \n  next();\n});\n\n// Apply rate limiting if enabled\nif (ENABLE_RATE_LIMITING) {\n  logger.info('Rate limiting enabled');\n  \n  const apiRateLimiter = new ApiRateLimiter({\n    points: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100', 10),\n    duration: parseInt(process.env.RATE_LIMIT_WINDOW || '60000', 10) / 1000,\n    keyGenerator: (req) => req.ip || 'unknown',\n    skip: (req) => req.path === '/health' // Skip rate limiting for health checks\n  });\n  \n  app.use(apiRateLimiter.middleware());\n}\n\n// SSE endpoint\napp.get('/sse', async (req, res, next) => {\n  try {\n    const transport = new SSEServerTransport('/messages', res);\n    \n    // Register with connection manager\n    connectionManager.registerConnection(transport.sessionId, transport);\n    \n    logger.info(`New SSE connection established: ${transport.sessionId}`);\n    \n    res.on('close', () => {\n      logger.info(`SSE connection closed: ${transport.sessionId}`);\n      connectionManager.unregisterConnection(transport.sessionId);\n    });\n    \n    await mcpServer.connect(transport);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Messages endpoint\napp.post('/messages', async (req, res, next) => {\n  try {\n    const sessionId = req.query.sessionId as string;\n    \n    if (!sessionId) {\n      throw new ApiError('Missing sessionId parameter', 400);\n    }\n    \n    const transport = connectionManager.getConnection(sessionId);\n    \n    // Update connection activity\n    connectionManager.updateActivity(sessionId);\n    \n    // Generate request ID for tracking\n    const requestId = `${sessionId}-${Date.now()}`;\n    connectionManager.startRequestTimer(requestId);\n    \n    if (transport) {\n      if (transport instanceof SSEServerTransport) {\n        await transport.handlePostMessage(req, res);\n      } else {\n        throw new ApiError('Invalid transport type for this endpoint', 400);\n      }\n      \n      // End request timer\n      connectionManager.endRequestTimer(requestId);\n    } else {\n      throw new ApiError(`No transport found for sessionId: ${sessionId}`, 400);\n    }\n  } catch (error) {\n    next(error);\n  }\n});\n\n// API routes (with versioning)\napp.use('/api', apiVersionManager.createVersioningMiddleware());\n\n// Health check endpoint\napp.get('/health', (_, res) => {\n  res.status(200).json({\n    status: 'ok',\n    name: SERVER_NAME,\n    version: SERVER_VERSION,\n    environment: NODE_ENV,\n    connections: {\n      sse: connectionManager.getConnectionCount(),\n      websocket: wsHandler.getConnectionCount(),\n      total: connectionManager.getConnectionCount() + wsHandler.getConnectionCount()\n    }\n  });\n});\n\n// Metrics endpoint\napp.get('/metrics', (_, res) => {\n  const uptime = Math.floor(process.uptime());\n  \n  res.status(200).json({\n    server: {\n      name: SERVER_NAME,\n      version: SERVER_VERSION,\n      environment: NODE_ENV,\n      uptime,\n      uptime_formatted: formatUptime(uptime)\n    },\n    connections: connectionManager.getStats(),\n    metrics: getMetrics(),\n    system: {\n      memory: process.memoryUsage(),\n      cpu: process.cpuUsage(),\n    },\n    cache: {\n      stats: cache.stats(),\n      keys: cache.keys().length\n    }\n  });\n});\n\n// Add error handling middleware\napp.use(notFound);\napp.use(errorHandler);\n\n// Format uptime helper\nfunction formatUptime(seconds: number): string {\n  const days = Math.floor(seconds / (24 * 60 * 60));\n  seconds -= days * 24 * 60 * 60;\n  const hours = Math.floor(seconds / (60 * 60));\n  seconds -= hours * 60 * 60;\n  const minutes = Math.floor(seconds / 60);\n  seconds -= minutes * 60;\n  \n  return `${days}d ${hours}h ${minutes}m ${Math.floor(seconds)}s`;\n}\n\n// Start server\nconst serverInstance = server.listen(PORT, () => {\n  logger.info(`${SERVER_NAME} v${SERVER_VERSION} running on port ${PORT}`);\n  logger.info(`Environment: ${NODE_ENV}`);\n  if (DEBUG) {\n    logger.info('Debug mode enabled');\n  }\n  logger.info(`WebSocket endpoint available at ws://localhost:${PORT}/ws`);\n  logger.info(`SSE endpoint available at http://localhost:${PORT}/sse`);\n  logger.info(`API Documentation available at http://localhost:${PORT}/api-docs`);\n});\n\n// Enable graceful shutdown\nprocess.on('SIGINT', gracefulShutdown);\nprocess.on('SIGTERM', gracefulShutdown);\n\n// Graceful shutdown function\nasync function gracefulShutdown() {\n  logger.info('Server shutting down gracefully...');\n  \n  try {\n    // Close WebSocket connections\n    await wsHandler.close();\n    logger.info('WebSocket server closed');\n    \n    // Clean up connection manager\n    connectionManager.cleanup();\n    logger.info('Connection manager cleaned up');\n    \n    // Close server\n    await new Promise<void>((resolve, reject) => {\n      serverInstance.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n    \n    logger.info('HTTP server closed');\n    process.exit(0);\n  } catch (error) {\n    logger.error(`Error during shutdown: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    process.exit(1);\n  }\n  \n  // If server doesn't close in 10 seconds, force exit\n  setTimeout(() => {\n    logger.error('Server shutdown timed out, forcing exit');\n    process.exit(1);\n  }, 10000);\n}\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n  logger.critical('Uncaught exception', error);\n  // Give the logger time to log the error before exiting\n  setTimeout(() => {\n    process.exit(1);\n  }, 1000);\n});\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (reason) => {\n  logger.critical('Unhandled promise rejection', reason instanceof Error ? reason : new Error(String(reason)));\n});\n